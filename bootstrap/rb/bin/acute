#!/usr/bin/env ruby

begin
  require 'rubygems'
  require 'bundler/setup'
rescue LoadError => e
  e.render
end

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)
require 'getoptlong'
require 'parslet'
require 'acute'
require 'llvm/core' 
require 'llvm/execution_engine'
require 'llvm/transforms/scalar'
require 'pp'

def usage
  puts "Usage: #{$0} [options]"
  puts " --eval, -e <code>     Evaluates the supplied code and exits"
  puts " --repl, -i            Runs the read-eval-print-loop, this is the default"
  puts " --bench, -b           Times how long the code takes to run"
  puts " --help, -h            This message"
end

opts = GetoptLong.new(
  ['--eval', '-e', GetoptLong::REQUIRED_ARGUMENT],
  ['--repl', '-i', GetoptLong::NO_ARGUMENT],
  ['--bench', '-b', GetoptLong::NO_ARGUMENT],
  ['--help', '-h', GetoptLong::NO_ARGUMENT]
)

bench = false
repl = false
file = nil
eval_string = nil
evals = []

opts.each do |opt, arg|
  case opt
    when '--help'
      usage
      exit 1
    when '--bench'
      bench = true
    when '--repl'
      repl = true
    when '--eval'
      eval_string = arg
  end
end

LLVM.init_x86
$module = ::LLVM::Module.create("AcuteBootstrap")
$engine = LLVM::ExecutionEngine.create_jit_compiler($module)
# We solve the chicken-egg problem by creating a new empty object as the lobby, we'll later set its parent
# to Object once we create Object.
lobby = ::Acute::Object.new
$state = ::Acute::State.new(lobby)
$state.init_protos

display = proc do |code|
  parser = Acute::Parser.new

  if bench
    require 'benchmark'
    Benchmark.bmbm do |x|
      x.report { tree = parser.parse(code) }
    end
  else
    begin
      tree = parser.parse(code)
    rescue Parslet::ParseFailed => error
      puts error, parser.root.error_tree
    end
  end

  begin
    puts "=> " + tree.perform_on({ :sender => lobby, :target => lobby, :msg => tree }, lobby, lobby).to_s
  rescue Exception => e
    puts "Exception: " + e.message
    puts "\t" + e.backtrace.join("\n\t")
  end
end

file = ARGV.last unless repl or eval_string
if file
  evals << File.read(file)
elsif eval_string
  evals << eval_string
end

if evals.empty?
  if $stdin.tty?
    require 'readline'
    loop do
      code = Readline.readline "Acute> "
      exit 0 unless code and code != "exit"
      display[code]
    end
  else
    evals << STDIN.read
  end
end

evals.each(&display)
