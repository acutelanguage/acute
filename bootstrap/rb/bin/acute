#!/usr/bin/env ruby

begin
  require 'rubygems'
  require 'bundler/setup'
rescue LoadError => e
  e.render
end

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)
require 'getoptlong'
require 'parslet'
require 'acute'
require 'llvm/core' 
require 'llvm/execution_engine'
require 'llvm/transforms/scalar'
require 'pp'

def usage
  puts "Usage: #{$0} [options]"
  puts " --eval, -e <code>     Evaluates the supplied code and exits"
  puts " --repl, -i            Runs the read-eval-print-loop, this is the default"
  puts " --bench, -b           Times how long the code takes to run"
  puts " --help, -h            This message"
end

opts = GetoptLong.new(
  ['--eval', '-e', GetoptLong::REQUIRED_ARGUMENT],
  ['--repl', '-i', GetoptLong::NO_ARGUMENT],
  ['--bench', '-b', GetoptLong::NO_ARGUMENT],
  ['--help', '-h', GetoptLong::NO_ARGUMENT]
)

bench = false
repl = false
file = nil
eval_string = nil
evals = []

opts.each do |opt, arg|
  case opt
    when '--help'
      usage
      exit 1
    when '--bench'
      bench = true
    when '--repl'
      repl = true
    when '--eval'
      eval_string = arg
  end
end

  LLVM.init_x86
  $module = ::LLVM::Module.create("AcuteBootstrap")
  $engine = LLVM::ExecutionEngine.create_jit_compiler($module)
   # We have a chicken-egg problem; which comes first? The Object or the Lobby?
  $Object = ::Acute::Object.new(true)
  # Chronologically, the Object of course, but...
  $Lobby = ::Acute::Object.new
  $Lobby.register(:parent, $Object)
  # We'll also make the Lobby a parent of Object. Don't worry, we solve lookup loops.
  $Object.register(:parent, $Lobby)
  $List = ::Acute::List.new
  $String = ::Acute::String.new
  $Number = ::Acute::Number.new(0, true)
  $Number.method_table
  $Nil = ::Acute::Nil.instance
  $Closure = ::Acute::Closure.new({})
  $Block = ::Acute::Block.new(nil, nil, [])
  $Message = ::Acute::Message.new("")
  $Slot = ::Acute::Slot.new($Nil, $Nil)
  $LLVMCore = ::Acute::LLVM::Core.new
  $LLVMTypes = ::Acute::LLVM::Types::Base.new
 
    $Lobby.register("Lobby", $Lobby)
    $Lobby.register("Object", $Object)
    $Lobby.register("List", $List)
    $Lobby.register("String", $String)
    $Lobby.register("Number", $Number)
    $Lobby.register("nil", $Nil)
    $Lobby.register("Closure", $Closure)
    $Lobby.register("Block", $Block)
    $Lobby.register("Message", $Message)
    $Lobby.register("Slot", $Slot)
    $Lobby.register("LLVM", $LLVMCore)
    $LLVMCore.register("Types", $LLVMTypes)
    $LLVMTypes.register("Pointer", ::Acute::LLVM::Types::Pointer.new)
    $LLVMTypes.register("Integer", ::Acute::LLVM::Types::Integer.new)

display = proc do |code|
  parser = Acute::Parser.new

  if bench
    require 'benchmark'
    Benchmark.bmbm do |x|
      x.report { tree = parser.parse(code) }
    end
  else
    tree = parser.parse(code)
  end

  begin

    puts "=> " + tree.perform_on({ :sender => $Lobby, :target => $Lobby, :msg => tree }, $Lobby, $Lobby).to_s
    #::Acute::Walker.walk($Lobby, tree) { |obj| puts "=> " + obj.to_s }
  end
end

file = ARGV.last unless repl or eval_string
if file
  evals << File.read(file)
elsif eval_string
  evals << eval_string
end

if evals.empty?
  if $stdin.tty?
    require 'readline'
    loop do
      code = Readline.readline "Acute> "
      exit 0 unless code and code != "exit"
      display[code]
    end
  else
    evals << STDIN.read
  end
end

evals.each(&display)
