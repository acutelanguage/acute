#!/usr/bin/env ruby

begin
  require 'rubygems'
  require 'bundler/setup'
rescue LoadError => e
  e.render
end

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)
require 'getoptlong'
require 'parslet'
require 'acute'
require 'pp'

def usage
  puts "Usage: #{$0} [options]"
  puts " --eval, -e <code>     Evaluates the supplied code and exits"
  puts " --repl, -i            Runs the read-eval-print-loop, this is the default"
  puts " --bench, -b           Times how long the code takes to run"
  puts " --help, -h            This message"
end

opts = GetoptLong.new(
  ['--eval', '-e', GetoptLong::REQUIRED_ARGUMENT],
  ['--repl', '-i', GetoptLong::NO_ARGUMENT],
  ['--bench', '-b', GetoptLong::NO_ARGUMENT],
  ['--help', '-h', GetoptLong::NO_ARGUMENT]
)

bench = false
repl = false
file = nil
eval_string = nil
evals = []

opts.each do |opt, arg|
  case opt
    when '--help'
      usage
      exit 1
    when '--bench'
      bench = true
    when '--repl'
      repl = true
    when '--eval'
      eval_string = arg
  end
end

display = proc do |code|
  # We have a chicken-egg problem; which comes first? The Object or the Lobby?
  $Object = ::Acute::Object.new(true)
  # Chronologically, the Object of course, but...
  $Lobby = ::Acute::Object.new
  $Lobby.register(:parent, $Object)
  # We'll also make the Lobby a parent of Object. Don't worry, we solve lookup loops.
  $Object.register(:parent, $Lobby)
  $List = ::Acute::List.new
  $String = ::Acute::String.new
  
  parser = Acute::Parser.new

  if bench
    require 'benchmark'
    Benchmark.bmbm do |x|
      x.report { tree = parser.parse(code) }
    end
  else
    tree = parser.parse(code)
  end

  begin
    puts "Message: " + tree.to_s
    $Lobby.register("Lobby", $Lobby)
    $Lobby.register("Object", $Object)
    $Lobby.register("List", $List)
    $Lobby.register("String", $String)
    ::Acute::Walker.walk($Lobby, tree) { |obj| puts "=> " + obj.to_s }
  end
end

file = ARGV.last unless repl or eval_string
if file
  evals << File.read(file)
elsif eval_string
  evals << eval_string
end

if evals.empty?
  if $stdin.tty?
    require 'readline'
    loop do
      code = Readline.readline "Acute> "
      exit 0 unless code and code != "exit"
      display[code]
    end
  else
    evals << STDIN.read
  end
end

evals.each(&display)
